- Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
- Если обработчик finally возвращает что-то, это игнорируется.
- Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.

Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.
В таком случае эти обработчики просто запускаются немедленно:
// Мгновенно выполнится
let promise = new Promise(resolve => resolve("готово!"));
promise.then(alert); // готово! (выведется сразу)

Вокруг функции промиса и обработчиков находится "невидимый try..catch"
Финальный .catch перехватывает как промисы, в которых вызван reject, так и случайные ошибки в обработчиках.

try..catch работает синхронно
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает.
Выход - писать не через - throw new Error, а через - reject(new Error())

fetch
Промис успешно выполняется и в свою очередь возвращает объект response после того, как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.