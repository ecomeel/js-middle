const user = {} - литеральная нотация / литерал объекта
delete user.age
'key' in obj => true / false
Object.assign(toObj, fromObjs) - копирование неглубокое
глубокое копирование - с помощью цикла / рекурсии / structureClone()

Строгий режим
this === underfind - вызов без объекта
Не строгий режим
this === globalObj

У стрелочных функций нет «this», оно берётся из внешней «нормальной» функции

Функции конструкторы:
function User(name) {
  this.name = name
}
const user1 = new User('Jack')
Когда функция вызывается как new User(...), происходит следующее:
-Создаётся новый пустой объект, и он присваивается this.
-Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
-Возвращается значение this.

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него

 Если в конструкторе есть return, то return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

 user?.address?.street
 user.loginAdmin?.()
 user?.[key]
 delete user?.name

- В логическом контексте все объекты являются true
- Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert / используем объект в качестве ключа
- Для преобразования объекта к числу, в случае математических операций:
  * явное преобразование
      num = Number(obj)
  * математические (не считая бинарного плюса)
      let n = +obj; // унарный плюс
      let delta = date1 - date2;
  * сравнения больше/меньше
      let greater = user1 > user2;
obj.toString()

Object.is(val1, val2) - сравнивает значения (===). Работает с NaN; 0 != -0 
Object.keys(obj) / .values(obj) => [key, key] / [value, value]
Object.entries(obj) => [ [ 'a', 10 ], [ 'b', 'string' ] ]
Object.fromEntries(obj) => {}
Object.* => возвращают реальные массивы

